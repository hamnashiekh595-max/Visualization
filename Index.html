<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>BST Auto Visualization</title>

<style>
    body {
        font-family: Arial, sans-serif;
        background: #f4f6f9;
        text-align: center;
    }

    h1 {
        margin-top: 20px;
    }

    svg {
        background: #ffffff;
        border: 1px solid #ccc;
        margin-top: 20px;
    }

    .node {
        fill: #4f46e5;
        stroke: #1e1b4b;
        stroke-width: 2;
    }

    .node-text {
        fill: white;
        font-size: 14px;
        text-anchor: middle;
        dominant-baseline: middle;
        font-weight: bold;
    }

    .edge {
        stroke: #000;
        stroke-width: 2;
    }
</style>
</head>

<body>

<h1>Binary Search Tree (Automatic)</h1>

<svg id="treeCanvas" width="1000" height="500"></svg>

<script>
class Node {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
    }
}

class BST {
    constructor() {
        this.root = null;
    }

    insert(value) {
        this.root = this._insertRec(this.root, value);
    }

    _insertRec(node, value) {
        if (node === null) return new Node(value);

        if (value < node.value)
            node.left = this._insertRec(node.left, value);
        else if (value > node.value)
            node.right = this._insertRec(node.right, value);

        return node;
    }
}

const bst = new BST();
const svg = document.getElementById("treeCanvas");
const levelGap = 70;

// ðŸ”¹ Predefined values (BST will auto-build)
const values = [50, 30, 70, 20, 40, 60, 80];

let index = 0;

// Auto insertion with delay
function autoInsert() {
    if (index >= values.length) return;

    bst.insert(values[index]);
    index++;
    drawTree();

    setTimeout(autoInsert, 800); // animation speed
}

function drawTree() {
    svg.innerHTML = "";
    if (!bst.root) return;

    calculatePositions(bst.root, 500, 40, 250);
    drawEdges(bst.root);
    drawNodes(bst.root);
}

function calculatePositions(node, x, y, offset) {
    if (!node) return;

    node.x = x;
    node.y = y;

    if (node.left)
        calculatePositions(node.left, x - offset, y + levelGap, offset / 2);

    if (node.right)
        calculatePositions(node.right, x + offset, y + levelGap, offset / 2);
}

function drawEdges(node) {
    if (!node) return;

    if (node.left) {
        drawLine(node.x, node.y, node.left.x, node.left.y);
        drawEdges(node.left);
    }

    if (node.right) {
        drawLine(node.x, node.y, node.right.x, node.right.y);
        drawEdges(node.right);
    }
}

function drawLine(x1, y1, x2, y2) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x1);
    line.setAttribute("y1", y1);
    line.setAttribute("x2", x2);
    line.setAttribute("y2", y2);
    line.setAttribute("class", "edge");
    svg.appendChild(line);
}

function drawNodes(node) {
    if (!node) return;

    drawCircle(node.x, node.y, node.value);

    drawNodes(node.left);
    drawNodes(node.right);
}

function drawCircle(x, y, value) {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", x);
    circle.setAttribute("cy", y);
    circle.setAttribute("r", 18);
    circle.setAttribute("class", "node");

    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y);
    text.setAttribute("class", "node-text");
    text.textContent = value;

    svg.appendChild(circle);
    svg.appendChild(text);
}

// Start automatically on load
autoInsert();
</script>

</body>
</html>
